{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Design of an Analog-Digital-Converter after the ADS1115\"\n",
        "---\n",
        "\n",
        "# VERY IMPORTANT, PLEASE READ\n",
        "\n",
        "To get the quarto output to behave properly, some steps have to be taken.\n",
        "\n",
        "1. When parsing data from .raw files, the toolbox will throw a warning. To prevent this, right click on \"l.parse()\" -> \"Go to definition\". There, you comment out  line 197 and the warning is gone.\n",
        "\n",
        "2. To justify text I added a custom command in \"styles.css\". To use this command and have the text appearance be nicer, use \"::: {.justify}\" at the beginning of each chapter\n",
        "\n",
        "3. Whenever referencing to a figure, some data file, etc. and you compile the whole document (\"report_grp4.qmd\") the paths specified have to be relative to the main document, otherwise quarto won't find the specified file\n",
        "\n",
        "4. If you need help with importing .raw files using python, please look at my version in chapters/clock_gen/clock_gen.qmd\n",
        "\n",
        "\n",
        "# Introduction\n",
        "Since more and more manufacturers are ending their production of integrated circuit solutions the development of full custom solutions is becomming more attractive. Thus, the different subgroups of the course \"Concept Engineering Mixed-Technology Systems\" held by Professor Meiners at Hochschule Bremen are tasked with creating an Analog-Digital-Converter modeled after the ADS1115 by Texas Instruments. In the following we present our approach to designing said ADC. This includes a theoretical analysis of the workings of $\\Sigma \\Delta$ ADC's, simulations of simplified models as well as a detailed step-by-step design using SPICE simulations based on XSchem designs. <font color=\"red\">THIS CAN BE WORDED WAY BETTER</font>.\n",
        "\n",
        "\n",
        "## General Overview of given ADC\n",
        "For testing purposes the ADS1115 is connected to an ADXL335 accelerometer and ESP8266 microcontroller. This setup enables us to more precisely characterize the ADC. For further analysis the accelerometer is just considered as an analog input. \n",
        "\n",
        "As can be seen in the above figure @fig-complete_system ...\n",
        "\n",
        "Figure @fig-adc_overview shows a more detailed block diagram of the ADS1115. The focus of our work lies on the components in the orange box. The theory for the digital filter stage following the modulator is also explored. The modulator itself comprises the switched capacitance to sample the input signal, an integrator and the comparator to output a PWM signal. \n",
        "The other blocks depicted are considered auxillary block. These include the multiplexer which can be used to switch between different inputs. It is followed by a programmable gain amplifier. The amplification factor can be selected via an I2C interface which is also used to select the input channel, sample rate, as well as for the read out of the converted digital data among others. Since these auxillary blocks do not add to the functionality of the modulator itself it was decided to not explore them any further. In case of the reference oscillator and the voltage reference, these are modeled as ideal inputs during simulations.\n",
        "\n",
        "![Block diagram internal structure ADS1115](figures/introduction/BlockDiagramm_ADS1115.svg){#fig-adc_overview}\n",
        "\n",
        "\n",
        "\n",
        "# General ADC characteristics\n",
        "\n",
        "# Theory of the Delta-Sigma Modulator\n",
        "::: {.justify}\n",
        "\n",
        "\n",
        "\n",
        "## System overview of the $\\Delta$ $\\Sigma$ modulator\n",
        "\n",
        "Delta-Sigma modulators ($\\Delta\\Sigma$) are generally speaking 1-bit sampling systems that utilizes the principles of \"oversampling\".\n",
        "To start this chapter of, we would like to briefly elaborate on some of the key elements that are commenly utilized by these modulator systems.\n",
        "\n",
        "The system itself can be represented, using the following block diagram for the case of analog-to-digital conversion.\n",
        "\n",
        "```{mermaid}\n",
        "flowchart LR\n",
        "  A[Anti-Alias Filtering] --> B[Sampling]\n",
        "  B --> C[Quantization]\n",
        "  C --> D[Digital Filtering]\n",
        "```\n",
        "\n",
        "Anti-Aliasing measures have to be considered to ensure a \"clean\" input signal to the modulator system, without unwanted parasitic components. \n",
        "\n",
        "The sampling then discretizes the input signal in time, before the quentization does the same with regard to its value (or amplitude).\n",
        "\n",
        "The digital filtering is then responsible to transform the discrete signal, which has been creates utilizing oversampling, into a more manageable format, typically utilizing \"moving-average filtering\".\n",
        "\n",
        "### Oversampling circuits\n",
        "\n",
        "\n",
        "### Principle of Noise Shaping\n",
        "\n",
        "The key advantage that Delta-Sigma Modulation brings to the table is \"noise shaping\". This is enabled by the feedback structure that is given in our modulator system.\n",
        "\n",
        "For that, let's observe the following block diagram.\n",
        "\n",
        "[add diagram and corresponding elaboration (for discrete-time domain would be better)]\n",
        "\n",
        "## Switched Capacitor Integrator as Loop Filter\n",
        "(to be cited: Schreier) \n",
        "\n",
        "The desired loop filter for the modulator, which is the first and most fundamental building block of our system, will be realised utilizing an active integrator circuit that has a switched capacitance input stage.\n",
        "\n",
        "A classic implementation of realizing an active integrator would be with the following opamp circuit in figure @opamp_integrator.\n",
        "\n",
        "![Simple opamp based integrator](figures/theory/Integrator_Circuit.svg){#opamp_integrator}\n",
        "\n",
        "(explain basic principle of shown integrator circuit)\n",
        "\n",
        "There is however the inconvinience, that the resistor on the input is generally a lossy and potentially noisy element for our system.\n",
        "\n",
        "Therefore, for our desired discrete integrator, it is worth utilizing the following input structure in Figure @opamp_sc_integrator, which leads to a switched-capacitor integrator. \n",
        "  \n",
        "![Opamp based switched capacitor integrator](figures/theory/SC_Integrator_Circuit.svg){#opamp_sc_integrator}\n",
        "\n",
        "The depicted switches are clocked in a way to ensure non-overlapping high levels, which would mess-up the circuit's functionality. \n",
        "\n",
        "To derive the system behaviour of this circuitry, let's consider the two phases of operation, given be the switching phases, depicted in Figures @phase1_integrator and @phase2_integrator.\n",
        "\n",
        "The first phase allows for the capacitor $C_1$ to be charged from the input, during which the integrating capacitor $C_2$ holds it's previous charge ($q_2[n]$).   \n",
        "\n",
        "![Integrator state during phase 1](figures/theory/sc_integrator_ph1.PNG){#phase1_integrator}\n",
        "\n",
        "![Integrator state during phase 2](figures/theory/sc_integrator_ph2.PNG){#phase2_integrator}\n",
        "\n",
        "This behaviour ultimately leads to the following description of out feedback system.\n",
        "\n",
        "\n",
        "![System Overview of the 1st order loopfilter](figures/theory/Simple_1stOrder_Mod_sys.png){#loopfilter_sys_1st_order}\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Clock-Phase generation\n",
        "\n",
        "::: {.justify}\n",
        "\n",
        "The aforementioned delay in the phases of the clocks acting on the switched capacitor can be achieved by the structure in figure @fig-phase_gen. This takes a reference clock signal which provides a signal at the frequency required by the system and outputs four different phases $\\phi_1$, $\\phi_{1d}$, $\\phi_2$ and $\\phi_{2d}$. The feedback between the upper and lower strand of the structure ensures the prevention of overlap between $\\phi_1$ and $\\phi_2$ and in turn for their respective delayed versions.\n",
        "\n",
        "![Basic structure for delayed clock phase generation](figures/clk_gen/schem_clock_generation.svg){#fig-phase_gen}\n",
        "\n",
        "By changing the capacitance of the marked inverters the actual delay between $\\phi_i$ and $\\phi_{id}$ can be controlled. It is worth noting however, that the capacitive load $C_L$ experienced at the outputs of the structure also has an influence on the phase delay, as can be seen in figure @fig-delay_norm"
      ],
      "id": "abcf6582"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-delay_norm\n",
        "#| fig-cap: Delayed clock signals\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import ltspice as lt\n",
        "\n",
        "#parse data from .raw file\n",
        "#for compiling the finished document this path needs to be relative to \"report_grp4.qmd\"\n",
        "fpath       = '../../matlab_python/clk_gen/tb_clkgen.raw'\n",
        "l           = lt.Ltspice(fpath)\n",
        "l.parse()\n",
        "\n",
        "#extract relevant data\n",
        "time        = l.get_time()\n",
        "vclk        = l.get_data('v(clkin)')\n",
        "vp1         = l.get_data('v(p1)')\n",
        "vp1e        = l.get_data('v(p1e)')\n",
        "vp2         = l.get_data('v(p2)')\n",
        "vp2e        = l.get_data('v(p2e)')\n",
        "\n",
        "#redefine data arrays considering new length\n",
        "factor = 10\n",
        "length = round(len(time)/factor)\n",
        "\n",
        "time    = time[:length]\n",
        "vclk    = np.flip(vclk[:length])\n",
        "vp1     = np.flip(vp1[:length])\n",
        "vp1e    = np.flip(vp1e[:length])\n",
        "vp2     = np.flip(vp2[:length])\n",
        "vp2e    = np.flip(vp2e[:length])\n",
        "\n",
        "#plot data\n",
        "plt.close('all')\n",
        "plt.figure(1)\n",
        "plt.plot(time*1e9, vp1, label=r'$\\phi_1$')\n",
        "plt.plot(time*1e9, vp1e, label=r'$\\phi_{1d}$')\n",
        "plt.plot(time*1e9, vp2, label=r'$\\phi_2$')\n",
        "plt.title('Voltage input clock over time')\n",
        "plt.xlabel('$t$/ns')\n",
        "plt.ylabel('V')\n",
        "plt.legend()\n",
        "plt.grid()"
      ],
      "id": "fig-delay_norm",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Figure @fig-delay_norm shows the normal delay between $\\phi_1$ and $\\phi_{1d}$ as well as the non-overlap with $\\phi_2$. The structure used for clock generation was modeled after the circuit provided by Boris Murman [@murmann]. In this, they used the *sg13g2* standard cells for the NAND gates and inverters which are not built from single transistors and hence their capacitance can not be changed. <font color=\"red\">This however does not affect the circuits ability to generate the needed delays and non-overlaps. Creating the gates from transistors, and in turn the whole structure, does show the same behaviour. TO BE CONFIRMED WITH ACUTAL SC/ADC FOLLOWING</font>.\n",
        "We thus continue to use the version with gate parameters controllable through the transistors. <font color=\"red\">WHY WAS THIS DECISION MADE?</font>\n",
        "\n",
        "The circuits used for the gates are depicted in figures @fig-inv and @fig-nand for the inverters and NAND gates respectively.\n",
        "\n",
        "::: {#fig-gates layout-ncol=2}\n",
        "![Inverter](figures/clk_gen/inverter.svg){#fig-inv}\n",
        "\n",
        "![NAND Gate](figures/clk_gen/nand_gate.svg){#fig-nand}\n",
        "\n",
        "Gates used for clock generating structures\n",
        ":::\n",
        "The cascading of two CMOS inverters in figure @fig-inv is needed to create a cleaner output, only using two devices in series will result in poorly defined high and low output levels. <font color=\"red\">REALLY?</font>\n",
        "\n",
        "\n",
        "# Comparator Design\n",
        "\n",
        "As the output stage of the modulator subsystem of the desired $\\Delta\\Sigma$ modulator, the comparator stage serves to realize the desired quantization to discretize the amplitude of our analog signal.\n",
        "A comparator suffices to realize a 1-bit quantization, where the representative output from our data samples is either \"high\" or \"low\".\n",
        "\n",
        "\n",
        "## Model-/ Architecture elaboration\n",
        "\n",
        "The considered implementation of our comparator utilizes an initial inverter based comparator stage, followed by a latching circuit to account for the reseting within the comparator and the resulting \"invalid\" outputs it would provide.\n",
        "Lastly it also utilizes a d-flip-flop for the \"digitized\" output signal(-s), to be fed back to the loopfilter structures.\n",
        "\n",
        "### Comparator Stage\n",
        "\n",
        "The comparator structure is realized through a symmetric architecture that is closely assossiated to the so called \"StrongArm\" architecture.\n",
        "It utilizes both n- and pmos transistors that are generally sized with small values for L, due to the main usage as switched. \n",
        "@strongarm_circuit.\n",
        "\n",
        "![Comparator, realized through inverter based architecture (placeholder)](figures/comp/comp_architecture.svg){#strongarm_circuit}\n",
        "\n",
        "(to be cited:\n",
        "\n",
        "- Low Voltage, Low Power, Inverter-Based\n",
        "Switched-Capacitor Delta-Sigma Modulator\n",
        "- Murmann lectures (e.g. 6)\n",
        ")\n",
        "\n",
        "This circuits behaviour is fundamentally tied to the clock states, leading to either the so called \"precharge\" phase during low clock levels, or the \"amplification\" phase during an active clock phase.\n",
        "\n",
        "During low clock phases the pmos transistors, directly tied to the supply rail, open up and therefore pull both the output nodes to $V_{DD}$. \n",
        "\n",
        "During high clock phases the nmos transistors start to conduct and allow for current to flow to the shared source contact of the input differential pair, so to $V_{SS}$ \n",
        "\n",
        "[tbd]\n",
        "\n",
        "### Latching Circuit\n",
        "\n",
        "After the StrongArm comparator, as mentioned previously, a latching circuit is implemented for improved validity of the final outputs.\n",
        "\n",
        "\n",
        "\n",
        "## Implementation\n",
        "\n",
        "[xschem circuit to be placed here]\n",
        "\n",
        "## Validation\n",
        "\n",
        "[some basic simulation plots to be placed here (validating clock behaviour, latching capability, etc.)]\n",
        "\n",
        "\n",
        "\n",
        "# References"
      ],
      "id": "49fb4f20"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\nicki\\anaconda3\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}