{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Design of an Analog-Digital-Converter after the ADS1115\"\n",
        "---\n",
        "\n",
        "# VERY IMPORTANT, PLEASE READ\n",
        "\n",
        "To get the quarto output to behave properly, some steps have to be taken.\n",
        "\n",
        "1. When parsing data from .raw files, the toolbox will throw a warning. To prevent this, right click on \"l.parse()\" -> \"Go to definition\". There, you comment out  line 197 and the warning is gone.\n",
        "\n",
        "2. To justify text I added a custom command in \"styles.css\". To use this command and have the text appearance be nicer, use \"::: {.justify}\" at the beginning of each chapter\n",
        "\n",
        "3. Whenever referencing to a figure, some data file, etc. and you compile the whole document (\"report_grp4.qmd\") the paths specified have to be relative to the main document, otherwise quarto won't find the specified file\n",
        "\n",
        "4. If you need help with importing .raw files using python, please look at my version in chapters/clock_gen/clock_gen.qmd\n",
        "\n",
        "\n",
        "# Introduction\n",
        "Since more and more manufacturers are ending their production of integrated circuit solutions the development of full custom solutions is becomming more attractive. Thus, the different subgroups of the course \"Concept Engineering Mixed-Technology Systems\" held by Professor Meiners at Hochschule Bremen are tasked with creating an Analog-Digital-Converter modeled after the ADS1115 by Texas Instruments. In the following we present our approach to designing said ADC. This includes a theoretical analysis of the workings of $\\Sigma \\Delta$ ADC's, simulations of simplified models as well as a detailed step-by-step design using SPICE simulations based on XSchem designs. <font color=\"red\">THIS CAN BE WORDED WAY BETTER</font>.\n",
        "\n",
        "\n",
        "## General Overview of given ADC\n",
        "For testing purposes the ADS1115 is connected to an ADXL335 accelerometer and ESP8266 microcontroller. This setup enables us to more precisely characterize the ADC. For further analysis the accelerometer is just considered as an analog input. \n",
        "\n",
        "As can be seen in the above figure @fig-complete_system ...\n",
        "\n",
        "Figure @fig-adc_overview shows a more detailed block diagram of the ADS1115. The focus of our work lies on the components in the orange box. The theory for the digital filter stage following the modulator is also explored. The modulator itself comprises the switched capacitance to sample the input signal, an integrator and the comparator to output a PWM signal. \n",
        "The other blocks depicted are considered auxillary block. These include the multiplexer which can be used to switch between different inputs. It is followed by a programmable gain amplifier. The amplification factor can be selected via an I2C interface which is also used to select the input channel, sample rate, as well as for the read out of the converted digital data among others. Since these auxillary blocks do not add to the functionality of the modulator itself it was decided to not explore them any further. In case of the reference oscillator and the voltage reference, these are modeled as ideal inputs during simulations.\n",
        "\n",
        "![Block diagram internal structure ADS1115](figures/introduction/BlockDiagramm_ADS1115.svg){#fig-adc_overview}\n",
        "\n",
        "\n",
        "\n",
        "# Theory\n",
        "::: {.justify}\n",
        "\n",
        "\n",
        "## System overview of the $\\Delta$ $\\Sigma$ modulator\n",
        "\n",
        "## Switched Capacitor Integrator\n",
        "(to be cited: Schreier) \n",
        "\n",
        "The desired loop filter for the modulator, which is the first and most fundamental building block of our system, will be realised utilizing an active integrator circuit that has a switched capacitance input stage.\n",
        "\n",
        "A classic implementation of realizing an active integrator would be with the following opamp circuit in figure @opamp_integrator.\n",
        "\n",
        "![Simple opamp based integrator](figures/theory/Integrator_Circuit.svg){#opamp_integrator}\n",
        "\n",
        "(explain basic principle of shown integrator circuit)\n",
        "\n",
        "There is however the inconvinience, that the resistor on the input is generally a lossy and potentially noisy element for our system.\n",
        "\n",
        "Therefore, it is worth utilizing the following input structure in figure @opamp_sc_integrator, which leads to a switched-capacitor integrator. \n",
        "  \n",
        "![Opamp based switched capacitor integrator](figures/theory/SC_Integrator_Circuit.svg){#opamp_sc_integrator}\n",
        "\n",
        "The depicted switches are clocked in a way, that no simultanious high levels will occure.\n",
        "\n",
        "To derive the system behaviour of this circuitry, let's consider the two phases of operation, given be the switching phases.\n",
        "\n",
        "![Integrator state during phase 1](figures/theory/sc_integrator_ph1.PNG){#phase1_integrator}\n",
        "\n",
        "![Integrator state during phase 2](figures/theory/sc_integrator_ph2.PNG){#phase2_integrator}\n",
        "\n",
        "### The Operational Transconductance Amplifier (OTA)\n",
        "\n",
        "For the loopfilter, there is the general need of operational amplifier. This could be done, via the classical OpAmp, for our case however, an operational transconductance amplifier, inn short OTA, will be used. It comes with a few key differentiating aspects, compared to the OpAmp.\n",
        "\n",
        "(list of OTA features will be added here)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Clock-Phase generation\n",
        "\n",
        "::: {.justify}\n",
        "\n",
        "The aforementioned delay in the phases of the clocks acting on the switched capacitor can be achieved by the structure in figure @fig-phase_gen. This takes a reference clock signal which provides a signal at the frequency required by the system and outputs four different phases $\\phi_1$, $\\phi_{1d}$, $\\phi_2$ and $\\phi_{2d}$. The feedback between the upper and lower strand of the structure ensures the prevention of overlap between $\\phi_1$ and $\\phi_2$ and in turn for their respective delayed versions.\n",
        "\n",
        "![Basic structure for delayed clock phase generation](figures/clk_gen/schem_clock_generation.svg){#fig-phase_gen}\n",
        "\n",
        "By changing the capacitance of the marked inverters the actual delay between $\\phi_i$ and $\\phi_{id}$ can be controlled. It is worth noting however, that the capacitive load $C_L$ experienced at the outputs of the structure also has an influence on the phase delay, as can be seen in figure @fig-delay_norm"
      ],
      "id": "338820a8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-delay_norm\n",
        "#| fig-cap: Delayed clock signals\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import ltspice as lt\n",
        "\n",
        "#parse data from .raw file\n",
        "#for compiling the finished document this path needs to be relative to \"report_grp4.qmd\"\n",
        "fpath       = '../../matlab_python/clk_gen/tb_clkgen.raw'\n",
        "l           = lt.Ltspice(fpath)\n",
        "l.parse()\n",
        "\n",
        "#extract relevant data\n",
        "time        = l.get_time()\n",
        "vclk        = l.get_data('v(clkin)')\n",
        "vp1         = l.get_data('v(p1)')\n",
        "vp1e        = l.get_data('v(p1e)')\n",
        "vp2         = l.get_data('v(p2)')\n",
        "vp2e        = l.get_data('v(p2e)')\n",
        "\n",
        "#redefine data arrays considering new length\n",
        "factor = 10\n",
        "length = round(len(time)/factor)\n",
        "\n",
        "time    = time[:length]\n",
        "vclk    = np.flip(vclk[:length])\n",
        "vp1     = np.flip(vp1[:length])\n",
        "vp1e    = np.flip(vp1e[:length])\n",
        "vp2     = np.flip(vp2[:length])\n",
        "vp2e    = np.flip(vp2e[:length])\n",
        "\n",
        "#plot data\n",
        "plt.close('all')\n",
        "plt.figure(1)\n",
        "plt.plot(time*1e9, vp1, label=r'$\\phi_1$')\n",
        "plt.plot(time*1e9, vp1e, label=r'$\\phi_{1d}$')\n",
        "plt.plot(time*1e9, vp2, label=r'$\\phi_2$')\n",
        "plt.title('Voltage input clock over time')\n",
        "plt.xlabel('$t$/ns')\n",
        "plt.ylabel('V')\n",
        "plt.legend()\n",
        "plt.grid()"
      ],
      "id": "fig-delay_norm",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Figure @fig-delay_norm shows the normal delay between $\\phi_1$ and $\\phi_{1d}$ as well as the non-overlap with $\\phi_2$. The structure used for clock generation was modeled after the circuit provided by Boris Murman [@murmann]. In this, they used the *sg13g2* standard cells for the NAND gates and inverters which are not built from single transistors and hence their capacitance can not be changed. <font color=\"red\">This however does not affect the circuits ability to generate the needed delays and non-overlaps. Creating the gates from transistors, and in turn the whole structure, does show the same behaviour. TO BE CONFIRMED WITH ACUTAL SC/ADC FOLLOWING</font>.\n",
        "We thus continue to use the version with gate parameters controllable through the transistors. <font color=\"red\">WHY WAS THIS DECISION MADE?</font>\n",
        "\n",
        "The circuits used for the gates are depicted in figures @fig-inv and @fig-nand for the inverters and NAND gates respectively.\n",
        "\n",
        "::: {#fig-gates layout-ncol=2}\n",
        "![Inverter](figures/clk_gen/inverter.svg){#fig-inv}\n",
        "\n",
        "![NAND Gate](figures/clk_gen/nand_gate.svg){#fig-nand}\n",
        "\n",
        "Gates used for clock generating structures\n",
        ":::\n",
        "The cascading of two CMOS inverters in figure @fig-inv is needed to create a cleaner output, only using two devices in series will result in poorly defined high and low output levels. <font color=\"red\">REALLY?</font>\n",
        "\n",
        "\n",
        "# Comparator Design\n",
        "\n",
        "As the output stage of the modulator subsystem of the desired Analog-Digital Converter, the comparator stage of the modulator serves as the quantizing block.\n",
        "\n",
        "## Model-/ Architecture elaboration\n",
        "\n",
        "The considered implementation of our comparator utilizes the so call \"StrongArm-Latch\" architecture, followed by a latching circuit to account for the reseting within the comparator and the resulting \"invalid\" outputs it would provide.\n",
        "\n",
        "### Comparator Stage\n",
        "\n",
        "@strongarm_circuit.\n",
        "\n",
        "![Comparator, realized through StrongArm architecture (placeholder)](figures/comp/StrongArm_placeholder.svg){#strongarm_circuit}\n",
        "\n",
        "(paper to be cited: DESIGN AND IMPLEMENTATION OF HIGH SPEED LATCHED COMPARATOR\n",
        "USING gm/Id SIZING METHOD\n",
        ")\n",
        "\n",
        "This circuits behaviour is fundamentally tied to the clock states, leading to either the so called \"precharge\" phase during low clock levels, or the \"amplification\" phase during an active clock phase.\n",
        "\n",
        "(Elaborate briefly on circuit behaviour)\n",
        "\n",
        "### Latching Circuit\n",
        "\n",
        "After the StrongArm comparator, as mentioned previously, a latching circuit is implemented for improved validity of the final outputs.\n",
        "\n",
        "\n",
        "\n",
        "## Implementation\n",
        "\n",
        "## Validation\n",
        "\n",
        "\n",
        "\n",
        "# References"
      ],
      "id": "dbcad59a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}