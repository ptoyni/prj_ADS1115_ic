{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Design of an Analog-Digital-Converter after the ADS1115\"\n",
        "---\n",
        "\n",
        "# VERY IMPORTANT, PLEASE READ\n",
        "\n",
        "To get the quarto output to behave properly, some steps have to be taken.\n",
        "\n",
        "1. When parsing data from .raw files, the toolbox will throw a warning. To prevent this, right click on \"l.parse()\" -> \"Go to definition\". There, you comment out  line 197 and the warning is gone.\n",
        "\n",
        "2. To justify text I added a custom command in \"styles.css\". To use this command and have the text appearance be nicer, use \"::: {.justify}\" at the beginning of each chapter\n",
        "\n",
        "3. Whenever referencing to a figure, some data file, etc. and you compile the whole document (\"report_grp4.qmd\") the paths specified have to be relative to the main document, otherwise quarto won't find the specified file\n",
        "\n",
        "4. If you need help with importing .raw files using python, please look at my version in chapters/clock_gen/clock_gen.qmd\n",
        "\n",
        "\n",
        "# Introduction\n",
        "Since more and more manufacturers are ending their production of integrated circuit solutions the development of full custom solutions is becomming more attractive. Thus, the different subgroups of the course \"Concept Engineering Mixed-Technology Systems\" held by Professor Meiners at Hochschule Bremen are tasked with creating an Analog-Digital-Converter modeled after the ADS1115 by Texas Instruments. In the following we present our approach to designing said ADC. This includes a theoretical analysis of the workings of $\\Sigma \\Delta$ ADC's, simulations of simplified models as well as a detailed step-by-step design using SPICE simulations based on XSchem designs. <font color=\"red\">THIS CAN BE WORDED WAY BETTER</font>.\n",
        "\n",
        "\n",
        "## General Overview of given ADC\n",
        "For testing purposes the ADS1115 is connected to an ADXL335 accelerometer and ESP8266 microcontroller. This setup enables us to more precisely characterize the ADC. For further analysis the accelerometer is just considered as an analog input. \n",
        "\n",
        "As can be seen in the above figure @fig-complete_system ...\n",
        "\n",
        "Figure @fig-adc_overview shows a more detailed block diagram of the ADS1115. The focus of our work lies on the components in the orange box. The theory for the digital filter stage following the modulator is also explored. The modulator itself comprises the switched capacitance to sample the input signal, an integrator and the comparator to output a PWM signal. \n",
        "The other blocks depicted are considered auxillary block. These include the multiplexer which can be used to switch between different inputs. It is followed by a programmable gain amplifier. The amplification factor can be selected via an I2C interface which is also used to select the input channel, sample rate, as well as for the read out of the converted digital data among others. Since these auxillary blocks do not add to the functionality of the modulator itself it was decided to not explore them any further. In case of the reference oscillator and the voltage reference, these are modeled as ideal inputs during simulations.\n",
        "\n",
        "![Block diagram internal structure ADS1115](figures/introduction/BlockDiagramm_ADS1115.svg){#fig-adc_overview}\n",
        "\n",
        "\n",
        "\n",
        "# Theory\n",
        "::: {.justify}\n",
        "\n",
        "\n",
        "## System overview of the $\\Delta$ $\\Sigma$ modulator\n",
        "\n",
        "## Switched Capacitor Integrator\n",
        "(to be cited: Schreier) \n",
        "\n",
        "The desired loop filter for the modulator, which is the first and most fundamental building block of our system, will be realised utilizing an active integrator circuit that has a switched capacitance input stage.\n",
        "\n",
        "A classic implementation of realizing an active integrator would be with the following opamp circuit in figure @opamp_integrator.\n",
        "\n",
        "![Simple opamp based integrator](figures/theory/Integrator_Circuit.svg){#opamp_integrator}\n",
        "\n",
        "(explain basic principle of shown integrator circuit)\n",
        "\n",
        "There is however the inconvinience, that the resistor on the input is generally a lossy and potentially noisy element for our system.\n",
        "\n",
        "Therefore, it is worth utilizing the following input structure in figure @opamp_sc_integrator, which leads to a switched-capacitor integrator. \n",
        "  \n",
        "![Opamp based switched capacitor integrator](figures/theory/SC_Integrator_Circuit.svg){#opamp_sc_integrator}\n",
        "\n",
        "The depicted switches are clocked in a way, that no simultanious high levels will occure.\n",
        "\n",
        "To derive the system behaviour of this circuitry, let's consider the two phases of operation, given be the switching phases.\n",
        "\n",
        "![Integrator state during phase 1](figures/theory/sc_integrator_ph1.PNG){#phase1_integrator}\n",
        "\n",
        "![Integrator state during phase 2](figures/theory/sc_integrator_ph2.PNG){#phase2_integrator}\n",
        "\n",
        "### The Operational Transconductance Amplifier (OTA)\n",
        "\n",
        "For the loopfilter, there is the general need of operational amplifier. This could be done, via the classical OpAmp, for our case however, an operational transconductance amplifier, inn short OTA, will be used. It comes with a few key differentiating aspects, compared to the OpAmp.\n",
        "\n",
        "(list of OTA features will be added here)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Clock-Phase generation\n",
        "\n",
        "::: {.justify}\n",
        "\n",
        "The aforementioned delay in the phases of the clocks acting on the switched capacitor can be achieved by the structure in figure @fig-phase_gen. This takes a reference clock signal which provides a signal at the frequency required by the system and outputs four different phases $\\phi_1$, $\\phi_{1d}$, $\\phi_2$ and $\\phi_{2d}$. The feedback between the upper and lower strand of the structure ensures the prevention of overlap between $\\phi_1$ and $\\phi_2$ and in turn for their respective delayed versions.\n",
        "\n",
        "![Basic structure for delayed clock phase generation](figures/clk_gen/schem_clock_generation.svg){#fig-phase_gen}\n",
        "\n",
        "By changing the capacitance of the marked inverters the actual delay between $\\phi_i$ and $\\phi_{id}$ can be controlled. It is worth noting however, that the capacitive load $C_L$ experienced at the outputs of the structure also has an influence on the phase delay, as can be seen in figure @fig-delay_norm"
      ],
      "id": "338820a8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-delay_norm\n",
        "#| fig-cap: Delayed clock signals\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import ltspice as lt\n",
        "\n",
        "#parse data from .raw file\n",
        "#for compiling the finished document this path needs to be relative to \"report_grp4.qmd\"\n",
        "fpath       = '../../matlab_python/clk_gen/tb_clkgen.raw'\n",
        "l           = lt.Ltspice(fpath)\n",
        "l.parse()\n",
        "\n",
        "#extract relevant data\n",
        "time        = l.get_time()\n",
        "vclk        = l.get_data('v(clkin)')\n",
        "vp1         = l.get_data('v(p1)')\n",
        "vp1e        = l.get_data('v(p1e)')\n",
        "vp2         = l.get_data('v(p2)')\n",
        "vp2e        = l.get_data('v(p2e)')\n",
        "\n",
        "#redefine data arrays considering new length\n",
        "factor = 10\n",
        "length = round(len(time)/factor)\n",
        "\n",
        "time    = time[:length]\n",
        "vclk    = np.flip(vclk[:length])\n",
        "vp1     = np.flip(vp1[:length])\n",
        "vp1e    = np.flip(vp1e[:length])\n",
        "vp2     = np.flip(vp2[:length])\n",
        "vp2e    = np.flip(vp2e[:length])\n",
        "\n",
        "#plot data\n",
        "plt.close('all')\n",
        "plt.figure(1)\n",
        "plt.plot(time*1e9, vp1, label=r'$\\phi_1$')\n",
        "plt.plot(time*1e9, vp1e, label=r'$\\phi_{1d}$')\n",
        "plt.plot(time*1e9, vp2, label=r'$\\phi_2$')\n",
        "plt.title('Voltage input clock over time')\n",
        "plt.xlabel('$t$/ns')\n",
        "plt.ylabel('V')\n",
        "plt.legend()\n",
        "plt.grid()"
      ],
      "id": "fig-delay_norm",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Figure @fig-delay_norm shows the normal delay between $\\phi_1$ and $\\phi_{1d}$ as well as the non-overlap with $\\phi_2$. The structure used for clock generation was modeled after the circuit provided by Boris Murman [@murmann]. In this, they used the *sg13g2* standard cells for the NAND gates and inverters which are not built from single transistors and hence their capacitance can not be changed. <font color=\"red\">This however does not affect the circuits ability to generate the needed delays and non-overlaps. Creating the gates from transistors, and in turn the whole structure, does show the same behaviour. TO BE CONFIRMED WITH ACUTAL SC/ADC FOLLOWING</font>.\n",
        "We thus continue to use the version with gate parameters controllable through the transistors. <font color=\"red\">WHY WAS THIS DECISION MADE?</font>\n",
        "\n",
        "The circuits used for the gates are depicted in figures @fig-inv and @fig-nand for the inverters and NAND gates respectively.\n",
        "\n",
        "::: {#fig-gates layout-ncol=2}\n",
        "![Inverter](figures/clk_gen/inverter.svg){#fig-inv}\n",
        "\n",
        "![NAND Gate](figures/clk_gen/nand_gate.svg){#fig-nand}\n",
        "\n",
        "Gates used for clock generating structures\n",
        ":::\n",
        "The cascading of two CMOS inverters in figure @fig-inv is needed to create a cleaner output, only using two devices in series will result in poorly defined high and low output levels. <font color=\"red\">REALLY?</font>\n",
        "\n",
        "\n",
        "# Comparator Design\n",
        "\n",
        "As the output stage of the modulator subsystem of the desired Analog-Digital Converter, the comparator stage of the modulator serves as the quantizing block.\n",
        "\n",
        "## Model-/ Architecture elaboration\n",
        "\n",
        "The considered implementation of our comparator utilizes the so call \"StrongArm-Latch\" architecture, followed by a latching circuit to account for the reseting within the comparator and the resulting \"invalid\" outputs it would provide.\n",
        "\n",
        "### Comparator Stage\n",
        "\n",
        "@strongarm_circuit.\n",
        "\n",
        "![Comparator, realized through StrongArm architecture (placeholder)](figures/comp/StrongArm_placeholder.svg){#strongarm_circuit}\n",
        "\n",
        "(paper to be cited: DESIGN AND IMPLEMENTATION OF HIGH SPEED LATCHED COMPARATOR\n",
        "USING gm/Id SIZING METHOD\n",
        ")\n",
        "\n",
        "This circuits behaviour is fundamentally tied to the clock states, leading to either the so called \"precharge\" phase during low clock levels, or the \"amplification\" phase during an active clock phase.\n",
        "\n",
        "(Elaborate briefly on circuit behaviour)\n",
        "\n",
        "### Latching Circuit\n",
        "\n",
        "After the StrongArm comparator, as mentioned previously, a latching circuit is implemented for improved validity of the final outputs.\n",
        "\n",
        "\n",
        "\n",
        "## Implementation\n",
        "\n",
        "## Validation\n",
        "\n",
        "\n",
        "\n",
        "# References"
      ],
      "id": "dbcad59a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Design of an Analog-Digital-Converter after the ADS1115\"\n",
        "---\n",
        "\n",
        "# VERY IMPORTANT, PLEASE READ\n",
        "\n",
        "To get the quarto output to behave properly, some steps have to be taken.\n",
        "\n",
        "1. When parsing data from .raw files, the toolbox will throw a warning. To prevent this, right click on \"l.parse()\" -> \"Go to definition\". There, you comment out  line 197 and the warning is gone.\n",
        "\n",
        "2. To justify text I added a custom command in \"styles.css\". To use this command and have the text appearance be nicer, use \"::: {.justify}\" at the beginning of each chapter\n",
        "\n",
        "3. Whenever referencing to a figure, some data file, etc. and you compile the whole document (\"report_grp4.qmd\") the paths specified have to be relative to the main document, otherwise quarto won't find the specified file\n",
        "\n",
        "4. If you need help with importing .raw files using python, please look at my version in chapters/clock_gen/clock_gen.qmd\n",
        "\n",
        "\n",
        "# Introduction\n",
        "Since more and more manufacturers are ending their production of integrated circuit solutions, the development of full custom solutions is becomming more attractive. Thus, the different subgroups of the course \"Concept Engineering Mixed-Technology Systems\", held by Professor Meiners at Hochschule Bremen, are tasked with the development of an Analog-Digital-Converter, roughly modeled in a way to replace the ADS1115 by Texas Instruments within a specified measurement system-chain. \n",
        "\n",
        "In the following we present our approach to designing said ADC. This includes a theoretical analysis of the workings of $\\Sigma \\Delta$ ADC's, an exploration of it's basic behavioural characteristics via system analysis, deriving basic and idealized circuits to match the behaviour, and lastly a detailed step-by-step design using SPICE simulations within the xschem design environment, where solutions on IC-level will be proposed. \n",
        "\n",
        "\n",
        "## Top-Level Overview of Considered System\n",
        "\n",
        "The considered system of interest for this semester is a classical meassurement system, consisting of an accelerometer as our analog data source, an ADC to convert said analog data to the digital domain, which can then be handled by a microcontroller as our processing unit.\n",
        "\n",
        "The specific board-level components that are considered for this signal-chain are the ADXL335 accelerometer, the ADS1115 ADC and an ESP8266 microcontroller.\n",
        "\n",
        "![Concerned Top-Level Measurement System](figures/introduction/toplvl_sys_overview.png){#fig_toplvl_view}\n",
        "\n",
        "The mentioned ICs are given as evaluation- & breakout boards as part of the lab inventory.\n",
        "\n",
        "![ADXL335 Functional Block Diagram [datasheet]](figures/introduction/ADXL335.PNG){#fig_ADXL_block}\n",
        "\n",
        "![ADS1115 Functional Block Diagram [datasheet]](figures/introduction/ADS1115.PNG){#fig_ADS_block}\n",
        "\n",
        "![ESP8266 Breakoutboard Pinout](figures/introduction/ESP8266_breakout.PNG){#fig_ESP8266}\n",
        "\n",
        "\n",
        "## General Overview of given ADC\n",
        "\n",
        "Figure @fig-adc_overview shows a more detailed block diagram of the ADS1115. The focus of our work lies on the components in the orange box. The theory for the digital filter stage following the modulator is also explored. The modulator itself comprises the switched capacitance to sample the input signal, an integrator and the comparator to output a PWM signal. \n",
        "The other blocks depicted are considered auxillary block. These include the multiplexer which can be used to switch between different inputs. It is followed by a programmable gain amplifier. The amplification factor can be selected via an I2C interface which is also used to select the input channel, sample rate, as well as for the read out of the converted digital data among others. Since these auxillary blocks do not add to the functionality of the modulator itself it was decided to not explore them any further. In case of the reference oscillator and the voltage reference, these are modeled as ideal inputs during simulations.\n",
        "\n",
        "![Block diagram internal structure ADS1115](figures/introduction/BlockDiagramm_ADS1115.svg){#fig-adc_overview}\n",
        "\n",
        "\n",
        "\n",
        "# Theory and Charactersitics of Delta-Sigma Modulators\n",
        "::: {.justify}\n",
        "\n",
        "\n",
        "## Top-Level Overview \n",
        "Delta-Sigma modulators ($\\Delta\\Sigma$) are generally speaking 1-bit sampling systems that utilizes the principles of \"oversampling\".\n",
        "To start this chapter of, we would like to briefly elaborate on some of the key elements that are commenly utilized by these modulator systems.\n",
        "\n",
        "The system itself can be represented, using the following block diagram for the case of analog-to-digital conversion.\n",
        "\n",
        "```{mermaid}\n",
        "flowchart LR\n",
        "  A[Anti-Alias Filtering] --> B[Sampling]\n",
        "  B --> C[Quantization]\n",
        "  C --> D[Digital Filtering]\n",
        "```\n",
        "\n",
        "Anti-Aliasing measures have to be considered to ensure a \"clean\" input signal to the modulator system, without unwanted parasitic components. \n",
        "\n",
        "The sampling then discretizes the input signal in time, before the quentization does the same with regard to its value (or amplitude).\n",
        "\n",
        "The digital filtering is then responsible to transform the discrete signal, which has been creates utilizing oversampling, into a more manageable format, typically utilizing \"moving-average filtering\".\n",
        "\n",
        "## System overview of $\\Delta\\Sigma$ Modulators\n",
        "\n",
        "### Oversampling circuits\n",
        "\n",
        "\n",
        "### Principle of Noise Shaping\n",
        "\n",
        "The key advantage that Delta-Sigma Modulation brings to the table is \"noise shaping\". This is enabled by the feedback structure that is given in our modulator system.\n",
        "\n",
        "For that, let's observe the following block diagram.\n",
        "\n",
        "[add diagram and corresponding elaboration (for discrete-time domain would be better)]\n",
        "\n",
        "### Behavioural Analysis using MATLAB\n",
        "\n",
        "![System Overview of the 1st order loopfilter](figures/theory/Simple_1stOrder_Mod_sys.png){#fig_loopfilter_sys_1st_order}\n",
        "\n",
        "\n",
        "![I/O behaviour from MATLAB simulation model](figures/theory/2nd_order_behav_output.svg){#opamp_sc_integrator}\n",
        "\n",
        "```{latex}\n",
        "\\begin{tikzpicture}\n",
        " \\draw (0,0) circle (1cm);\n",
        " %\\pause\n",
        " \\draw (0,0) circle (2cm);\n",
        "\\end{tikzpicture}\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Basic Behaviour on Circuit Level\n",
        "\n",
        "(to be cited: Schreier) \n",
        "\n",
        "## Switched Capacitor Integrator as Loop Filter \n",
        "The desired loop filter for the modulator, which is the first and most fundamental building block of our system, will be realised utilizing an active integrator circuit that has a switched capacitance input stage.\n",
        "\n",
        "A classic implementation of realizing an active integrator would be with the following opamp circuit in figure @opamp_integrator.\n",
        "\n",
        "![Simple opamp based integrator](figures/theory/Integrator_Circuit.svg){#opamp_integrator}\n",
        "\n",
        "(explain basic principle of shown integrator circuit)\n",
        "\n",
        "There is however the inconvinience, that the resistor on the input is generally a lossy and potentially noisy element for our system.\n",
        "\n",
        "Therefore, for our desired discrete integrator, it is worth utilizing the following input structure in Figure @opamp_sc_integrator, which leads to a switched-capacitor integrator. \n",
        "  \n",
        "![Opamp based switched capacitor integrator](figures/theory/SC_Integrator_Circuit.svg){#opamp_sc_integrator}\n",
        "\n",
        "The depicted switches are clocked in a way to ensure non-overlapping high levels, which would mess-up the circuit's functionality. \n",
        "\n",
        "To derive the system behaviour of this circuitry, let's consider the two phases of operation, given be the switching phases, depicted in Figures @phase1_integrator and @phase2_integrator.\n",
        "\n",
        "![Integrator state during phase 1](figures/theory/sc_integrator_ph1.PNG){#phase1_integrator}\n",
        "\n",
        "![Integrator state during phase 2](figures/theory/sc_integrator_ph2.PNG){#phase2_integrator}\n",
        "\n",
        "The first phase allows for the capacitor $C_1$ to be charged from the input, leading to the charge accumulation $q_1[1]$, during which the integrating capacitor $C_2$ holds it's previous charge ($q_2[n]$). Due to the relation $V = \\frac{Q}{C}$, the output voltage will be equal to the ratio of that charge $q_2[n]$ to the capacitance $C_2$.\n",
        "\n",
        "The second phase will than result in the charge of $C_1$ to accumulate in $C_2$, due to the opamps input behaviour related to it's \"virtual ground\". C2 will therefore have the sum of charges, leading to\n",
        "\n",
        "\\begin{align}\\label{sc_charge_ph2}\n",
        "  q_2[n+1] = q_2 + q_1. \n",
        "\\end{align}\n",
        "\n",
        "After applying the $z$-transform, the result is\n",
        "\n",
        "\\begin{align}\n",
        "  Q_2(z) = Q_2(z)\\,z^{-1} + Q_1(z)\\,z^{-1}\n",
        "\\end{align}\n",
        "\n",
        "which in turn can be rearranged to get\n",
        "\n",
        "\\begin{align}\n",
        "  \\frac{Q_2(z)}{Q_1(z)} = \\frac{z^{-1}}{1-z^{-1}}\n",
        "\\end{align}\n",
        "\n",
        "Utilizing the aforementions relation between voltage, charge and capacitance, we can derive the voltage I/O behaviour (transfer function) to be the following\n",
        "\n",
        "\\begin{align}\n",
        "  \\frac{V_{out}}{V_{in}} = \\frac{z^{-1}}{1-z^{-1}} \\frac{C1}{C2} = H_v(z)\n",
        "\\end{align}\n",
        "\n",
        "The ratio of the capacitors would be a potential gain factor for the, which could also be choosen to achieve unity gain ($C_1 = C_2$).\n",
        "\n",
        "The remaining term, describing a delayed integrator, is what will be utilized in the MATLAB assited system analysis. That ultimately leads to the following description of out feedback system, which overlaps with the established linear model from our system analysis in MATLAB, previously shown in Figure @fig_loopfilter_sys_1st_order.\n",
        "\n",
        "\n",
        "\n",
        "# Design Proposals\n",
        "This chapter shall highlight our attempts at realizing the desired subsystems of the $\\Delta\\Sigma$ modulator on transistor level, utilizing the 130 nm technology offered from the IHP's sg13g2 BiCMOS PDK for open source usage.\n",
        "\n",
        "The following subchapters will elaborate on the separate subcircuits, briefly explain the workings of the circuits before going over the achieved simulation results. Xschem was used as the schematic capture EDA tool, while the testbench-driven simulations utilize ngspice. \n",
        "\n",
        "\n",
        "## Clock-Phase generation\n",
        "\n",
        "::: {.justify}\n",
        "\n",
        "The aforementioned delay in the phases of the clocks acting on the switched capacitor can be achieved by the structure in figure @fig-phase_gen. This takes a reference clock signal which provides a signal at the frequency required by the system and outputs four different phases $\\phi_1$, $\\phi_{1d}$, $\\phi_2$ and $\\phi_{2d}$. The feedback between the upper and lower strand of the structure ensures the prevention of overlap between $\\phi_1$ and $\\phi_2$ and in turn for their respective delayed versions.\n",
        "\n",
        "![Basic structure for delayed clock phase generation](figures/clk_gen/schem_clock_generation.svg){#fig-phase_gen}\n",
        "\n",
        "By changing the capacitance of the marked inverters the actual delay between $\\phi_i$ and $\\phi_{id}$ can be controlled. It is worth noting however, that the capacitive load $C_L$ experienced at the outputs of the structure also has an influence on the phase delay, as can be seen in figure @fig-delay_norm"
      ],
      "id": "32260b30"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-delay_norm\n",
        "#| fig-cap: Delayed clock signals\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import ltspice as lt\n",
        "\n",
        "#parse data from .raw file\n",
        "#for compiling the finished document this path needs to be relative to \"report_grp4.qmd\"\n",
        "fpath       = '../../matlab_python/clk_gen/tb_clkgen.raw'\n",
        "l           = lt.Ltspice(fpath)\n",
        "l.parse()\n",
        "\n",
        "#extract relevant data\n",
        "time        = l.get_time()\n",
        "vclk        = l.get_data('v(clkin)')\n",
        "vp1         = l.get_data('v(p1)')\n",
        "vp1e        = l.get_data('v(p1e)')\n",
        "vp2         = l.get_data('v(p2)')\n",
        "vp2e        = l.get_data('v(p2e)')\n",
        "\n",
        "#redefine data arrays considering new length\n",
        "factor = 10\n",
        "length = round(len(time)/factor)\n",
        "\n",
        "time    = time[:length]\n",
        "vclk    = np.flip(vclk[:length])\n",
        "vp1     = np.flip(vp1[:length])\n",
        "vp1e    = np.flip(vp1e[:length])\n",
        "vp2     = np.flip(vp2[:length])\n",
        "vp2e    = np.flip(vp2e[:length])\n",
        "\n",
        "#plot data\n",
        "plt.close('all')\n",
        "plt.figure(1)\n",
        "plt.plot(time*1e9, vp1, label=r'$\\phi_1$')\n",
        "plt.plot(time*1e9, vp1e, label=r'$\\phi_{1d}$')\n",
        "plt.plot(time*1e9, vp2, label=r'$\\phi_2$')\n",
        "plt.title('Voltage input clock over time')\n",
        "plt.xlabel('$t$/ns')\n",
        "plt.ylabel('V')\n",
        "plt.legend()\n",
        "plt.grid()"
      ],
      "id": "fig-delay_norm",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Figure @fig-delay_norm shows the normal delay between $\\phi_1$ and $\\phi_{1d}$ as well as the non-overlap with $\\phi_2$. The structure used for clock generation was modeled after the circuit provided by Boris Murman [@murmann]. In this, they used the *sg13g2* standard cells for the NAND gates and inverters which are not built from single transistors and hence their capacitance can not be changed. <font color=\"red\">This however does not affect the circuits ability to generate the needed delays and non-overlaps. Creating the gates from transistors, and in turn the whole structure, does show the same behaviour. TO BE CONFIRMED WITH ACUTAL SC/ADC FOLLOWING</font>.\n",
        "We thus continue to use the version with gate parameters controllable through the transistors. <font color=\"red\">WHY WAS THIS DECISION MADE?</font>\n",
        "\n",
        "The circuits used for the gates are depicted in figures @fig-inv and @fig-nand for the inverters and NAND gates respectively.\n",
        "\n",
        "::: {#fig-gates layout-ncol=2}\n",
        "![Inverter](figures/clk_gen/inverter.svg){#fig-inv}\n",
        "\n",
        "![NAND Gate](figures/clk_gen/nand_gate.svg){#fig-nand}\n",
        "\n",
        "Gates used for clock generating structures\n",
        ":::\n",
        "The cascading of two CMOS inverters in figure @fig-inv is needed to create a cleaner output, only using two devices in series will result in poorly defined high and low output levels. <font color=\"red\">REALLY?</font>\n",
        "\n",
        "\n",
        "## Comparator Design\n",
        "\n",
        "As the output stage of the modulator subsystem of the desired $\\Delta\\Sigma$ modulator, the comparator stage serves to realize the desired quantization to discretize the amplitude of our analog signal.\n",
        "A comparator suffices to realize a 1-bit quantization, where the representative output from our data samples is either \"high\" or \"low\", which will do fine to give us the PWM signal at the output.\n",
        "\n",
        "\n",
        "### Model-/ Architecture elaboration\n",
        "\n",
        "The considered implementation of our comparator utilizes an initial inverter based comparator stage, followed by a latching circuit to account for the reseting within the comparator and the resulting \"invalid\" outputs it would provide.\n",
        "Lastly it also utilizes a d-flip-flop for the \"digitized\" output signal(-s), to be fed back to the loopfilter structures.\n",
        "\n",
        "### Comparator Stage\n",
        "\n",
        "The comparator structure is realized through a symmetric architecture that is closely assossiated to the so called \"StrongArm\" architecture.\n",
        "It utilizes both n- and pmos transistors that are generally sized with small values for L, due to the main usage as switched. \n",
        "@strongarm_circuit.\n",
        "\n",
        "![Comparator, realized through inverter based architecture (placeholder)](figures/comp/comp_architecture.svg){#strongarm_circuit}\n",
        "\n",
        "(to be cited:\n",
        "\n",
        "- Low Voltage, Low Power, Inverter-Based\n",
        "Switched-Capacitor Delta-Sigma Modulator\n",
        "- Murmann lectures (e.g. 6)\n",
        ")\n",
        "\n",
        "This circuits behaviour is fundamentally tied to the clock states, leading to either the so called \"precharge\" phase during low clock levels, or the \"amplification\" phase during an active clock phase.\n",
        "\n",
        "During low clock phases the pmos transistors, directly tied to the supply rail, open up and therefore pull both the output nodes to $V_{DD}$. \n",
        "\n",
        "During high clock phases the nmos transistors start to conduct and allow for current to flow to the shared source contact of the input differential pair, so to $V_{SS}$ \n",
        "\n",
        "[tbd]\n",
        "\n",
        "### Latching Circuit\n",
        "\n",
        "After the StrongArm comparator, as mentioned previously, a latching circuit is implemented for improved validity of the final outputs.\n",
        "\n",
        "### Implementation\n",
        "\n",
        "[xschem circuit to be placed here]\n",
        "\n",
        "### Validation\n",
        "\n",
        "[some basic simulation plots to be placed here (validating clock behaviour, latching capability, etc.)]\n"
      ],
      "id": "5a1a8664"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import ltspice as lt\n",
        "\n",
        "#parse data from .raw file\n",
        "#for compiling the finished document this path needs to be relative to \"report_grp4.qmd\"\n",
        "fpath       = '../../design/design_comp/simulations/tb_comp_test.raw'\n",
        "l           = lt.Ltspice(fpath)\n",
        "l.parse()\n",
        "\n",
        "#extract relevant data\n",
        "time        = l.get_time()\n",
        "clk         = l.get_data('v(clk)')\n",
        "outp        = l.get_data('v(outp)')\n",
        "outn        = l.get_data('v(outn)')\n",
        "out2dff     = l.get_data('v(out2dff)')\n",
        "nout2dff    = l.get_data('v(nout2dff)')\n",
        "\n",
        "#redefine data arrays considering new length\n",
        "'''\n",
        "factor = 10\n",
        "length = round(len(time)/factor)\n",
        "\n",
        "time        = time[:length]\n",
        "clk         = np.flip(clk[:length])\n",
        "outp        = np.flip(outp[:length])\n",
        "outn        = np.flip(outn[:length])\n",
        "out2dff     = np.flip(out2dff[:length])\n",
        "nout2dff    = np.flip(nout2dff[:length])\n",
        "'''\n",
        "\n",
        "#plot data\n",
        "plt.close('all')\n",
        "plt.figure(1)\n",
        "plt.plot(time*1e9, clk, label=r'clk')\n",
        "plt.plot(time*1e9, outp, label=r'outp')\n",
        "plt.plot(time*1e9, outn, label=r'outn')\n",
        "plt.title('Output Voltages from StrongArm Comparator')\n",
        "plt.xlabel('time/ ns'); plt.ylabel('Voltage/ V')\n",
        "plt.legend(); plt.grid()\n",
        "\n",
        "plt.figure(2)\n",
        "plt.plot(time*1e9, out2dff, label=r'to d-flip-flop')\n",
        "plt.plot(time*1e9, nout2dff, label=r'complement')\n",
        "plt.title('Output of RS-Latch')\n",
        "plt.xlabel('time/ ns'); plt.ylabel('Voltage/ V')\n",
        "plt.legend(); plt.grid()"
      ],
      "id": "d2d6c26f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Digital Output Filtering\n",
        "::: {.justify}\n",
        "\n",
        "The topic of digital filtering and decimation after the actual modulator stage could not be explored extensively during this semester. We do however want to briefly that subsystem from a conceptual perspective.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# References"
      ],
      "id": "f4c57868"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\nicki\\anaconda3\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}